{"ast":null,"code":"/* tslint:disable:max-line-length */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { updateItem, resolveItemsIds } from './utils/itemUtils';\nimport { EXPAND_FIELD, SELECT_FIELD, CHECK_FIELD, CHECK_INDETERMINATE_FIELD } from './utils/consts';\nimport { getNestedValue, isArray } from './utils/misc';\n/**\n * A helper function which applies the specified operation descriptors to the data.\n * * [Expanding and collapsing items]({% slug expansion_ways_treeview %}#toc-using-a-helper-function)\n * * [Selecting and deselecting items]({% slug selection_ways_treeview %}#toc-using-a-helper-function)\n * * [Checking and unchecking items]({% slug check_helper_funcs_treeview %})\n *\n * @param data - The data that will be processed.\n * @param operations - The operation descriptors that will be applied to the data.\n * @returns - The processed copy of the input data.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     state = { items: tree, expand: [], select: [], check: [] };\n *     render() {\n *         const { expand, select, check } = this.state;\n *         return (\n *             <TreeView\n *                 data={processTreeViewItems(this.state.items, { expand, select, check })}\n *                 expandIcons={true} onExpandChange={this.onExpandChange} checkboxes={true}\n *                 onCheckChange={event => this.setState({ check: [ event.itemHierarchicalIndex ] })}\n *                 onItemClick={event => this.setState({ select: [ event.itemHierarchicalIndex ] })}\n *             />\n *         );\n *     }\n *     onExpandChange = (event) => {\n *         let expand = this.state.expand.slice();\n *         const index = expand.indexOf(event.itemHierarchicalIndex);\n *         index === -1 ? expand.push(event.itemHierarchicalIndex) : expand.splice(index, 1);\n *         this.setState({ expand });\n *     }\n * }\n *\n * const tree = [{\n *     text: 'Item1',\n *     items: [\n *         { text: 'Item1.1' },\n *         { text: 'Item1.2' },\n *         { text: 'Item1.3', items: [{ text: 'Item1.3.1' }] }]\n * }, {\n *     text: 'Item2', disabled: true,\n *     items: [{ text: 'Item2.1' }, { text: 'Item2.2' }, { text: 'Item2.3' }]\n * }, {\n *     text: 'Item3'\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\n\nexport default function processTreeViewItems(data, operations) {\n  if (!data || !data.length) {\n    return [];\n  }\n\n  var result = data;\n  var cloneField = operations.cloneField || 'cloned';\n  result = handleOperation(result, EXPAND_FIELD, operations.expand, cloneField);\n  result = handleOperation(result, SELECT_FIELD, operations.select, cloneField);\n  result = handleOperation(result, CHECK_FIELD, operations.check, cloneField);\n  applyCheckIndeterminate(result, operations.check);\n  return result;\n}\n\nfunction handleOperation(items, defaultField, operation, cloneField) {\n  if (operation) {\n    var _a = parseOperation(operation, defaultField),\n        ids = _a.ids,\n        field = _a.field;\n\n    var indices = !isArray(operation) && operation.idField ? resolveItemsIds(ids, operation.idField, items) : ids;\n    return raiseFlags(items, indices, field, cloneField);\n  } else {\n    return items;\n  }\n}\n\nfunction parseOperation(operation, defaultField) {\n  var ids;\n  var field;\n\n  if (isArray(operation)) {\n    ids = operation;\n    field = defaultField;\n  } else {\n    ids = operation.ids || [];\n    field = operation.operationField || defaultField;\n  }\n\n  return {\n    ids: ids,\n    field: field\n  };\n}\n\nfunction raiseFlags(items, indices, field, cloneField) {\n  var result = items;\n  indices.forEach(function (itemIndex) {\n    result = updateItem(result, itemIndex, function (item) {\n      return raiseNestedFlag(field, item);\n    }, cloneField);\n  });\n  return result;\n}\n\nfunction raiseNestedFlag(fieldName, dataItem) {\n  var fields = (fieldName || '').split('.');\n  var item = dataItem;\n\n  for (var index = 0; index < fields.length; index++) {\n    var field = fields[index];\n\n    if (index === fields.length - 1) {\n      item[field] = true;\n    } else if (item[field] !== undefined) {\n      item[field] = __assign({}, item[field]);\n      item = item[field];\n    } else {\n      return;\n    }\n  }\n}\n\nfunction applyCheckIndeterminate(items, check) {\n  if (check && !isArray(check) && check.applyCheckIndeterminate) {\n    var checkField = parseOperation(check, CHECK_FIELD).field;\n    var checkIndeterminateField = check.checkIndeterminateField || CHECK_INDETERMINATE_FIELD;\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (item.items) {\n        applyCheckIndeterminateHelper(item.items, getNestedValue(checkField, item) ? [] : [item], checkField, checkIndeterminateField);\n      }\n    }\n  }\n}\n\nfunction applyCheckIndeterminateHelper(data, parents, checkField, checkIndeterminateField) {\n  // The updates will be direct because the corresponding items\n  // are already cloned because of their checked children.\n  var parentsAlreadyUpdated = false;\n\n  for (var i = 0; i < data.length; i++) {\n    var item = data[i];\n\n    if (getNestedValue(checkField, item)) {\n      if (!parentsAlreadyUpdated) {\n        for (var j = 0; j < parents.length; j++) {\n          raiseNestedFlag(checkIndeterminateField, parents[j]);\n        }\n      }\n\n      parentsAlreadyUpdated = true;\n\n      if (item.items) {\n        applyCheckIndeterminateHelper(item.items, [], checkField, checkIndeterminateField);\n      }\n    } else {\n      if (item.items) {\n        applyCheckIndeterminateHelper(item.items, parentsAlreadyUpdated ? [item] : parents.concat([item]), checkField, checkIndeterminateField);\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}