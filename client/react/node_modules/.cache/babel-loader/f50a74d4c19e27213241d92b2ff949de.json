{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { orderBy as kendoDataQueryOrderBy, filterBy as kendoDataQueryFilterBy } from '@progress/kendo-data-query'; // Gets and sets the children. Returns the children or the re-created item with the new children.\n\nfunction children(item, subItemsField, subItems) {\n  var _a;\n\n  if (subItems) {\n    return __assign({}, item, (_a = {}, _a[subItemsField] = subItems.length ? subItems.slice() : undefined, _a));\n  } else {\n    return item && item[subItemsField] ? item[subItemsField].slice() : [];\n  }\n}\n\nfunction sortChildren(dataItem, sort, subItemsField) {\n  var _a;\n\n  if (dataItem[subItemsField]) {\n    var item = children(dataItem, subItemsField, kendoDataQueryOrderBy(children(dataItem, subItemsField), sort));\n    var subItems = children(item, subItemsField).map(function (root) {\n      return sortChildren(root, sort, subItemsField);\n    });\n    return __assign({}, item, (_a = {}, _a[subItemsField] = subItems, _a));\n  }\n\n  return dataItem;\n}\n/**\n * Orders the specified tree according to the provided sort descriptors.\n *\n * @param {T[]} data - The data that will be sorted.\n * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {T[]} - The sorted data.\n */\n\n\nexport function orderBy(data, descriptors, subItemsField) {\n  var sorted = kendoDataQueryOrderBy(data, descriptors);\n  sorted = sorted.map(function (dataItem) {\n    return sortChildren(dataItem, descriptors, subItemsField);\n  });\n  return sorted;\n}\n\nfunction filterChildren(dataItem, filters, subItemsField) {\n  var subItems = children(dataItem, subItemsField);\n\n  if (subItems && subItems.length) {\n    subItems = subItems.map(function (item) {\n      return filterChildren(item, filters, subItemsField);\n    });\n    var hasChildrenFilter = {\n      operator: function operator(item) {\n        return Boolean((item[subItemsField] || []).length);\n      }\n    };\n    var filter = {\n      filters: [{\n        filters: filters,\n        logic: 'and'\n      }, hasChildrenFilter],\n      logic: 'or'\n    };\n    var filtered = kendoDataQueryFilterBy(subItems, filter);\n    return children(dataItem, subItemsField, filtered);\n  }\n\n  return dataItem;\n}\n/**\n * Filters the provided data tree according to the specified `Array<FilterDescriptor|CompositeFilterDescriptor>`.\n *\n * @param {T[]} data - The data that will be filtered.\n * @param {FilterDescriptor[]|CompositeFilterDescriptor[]} descriptors - The filter criteria that will be applied.\n * @param {string} subItemsField - The field which points to the subitems collection of each data item.\n * @returns {T[]} - The filtered data.\n */\n\n\nexport function filterBy(data, descriptors, subItemsField) {\n  var _a;\n\n  var filtered = (_a = {}, _a[subItemsField] = data.slice(), _a);\n  filtered = filterChildren(filtered, descriptors, subItemsField);\n  return filtered[subItemsField] || [];\n}","map":null,"metadata":{},"sourceType":"module"}