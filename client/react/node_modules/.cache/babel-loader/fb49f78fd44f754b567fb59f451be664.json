{"ast":null,"code":"import { guid, Keys } from '@progress/kendo-react-common';\nimport { findId, findNextIdByCellIndex, findNextIdByRowIndex, getBodyElement, getHeaderElement, getNavigatableId, tableKeyboardNavigationTools as navigationTools } from './utils';\nimport { KEYBOARD_NAV_FILTER_COL_SUFFIX } from './constants';\n/**\n * @hidden\n */\n\nvar onConstructor = function onConstructor(options) {\n  var navigatable = options.navigatable,\n      contextStateRef = options.contextStateRef,\n      navigationStateRef = options.navigationStateRef,\n      idPrefix = options.idPrefix; // v.2: check if nested navigation\n\n  if (navigatable) {\n    contextStateRef.current = {\n      activeId: '',\n      level: 0\n    };\n    navigationStateRef.current = {\n      activeElementIsFocused: false,\n      prevNavigationIndexes: undefined,\n      idPrefix: idPrefix || guid(),\n      navigationMatrix: [],\n      lastHeaderIndex: -1\n    };\n  }\n};\n/**\n * @hidden\n */\n\n\nvar onComponentDidMount = function onComponentDidMount(options) {\n  var scope = options.scope,\n      contextStateRef = options.contextStateRef,\n      navigationStateRef = options.navigationStateRef;\n\n  if (contextStateRef.current && navigationStateRef.current && scope) {\n    generateMatrix(options);\n    var firstId = navigationStateRef.current.navigationMatrix[0][0];\n    var firstIdElement = navigationTools.getActiveElement(scope, firstId);\n\n    if (firstId && firstIdElement) {\n      contextStateRef.current.activeId = firstId;\n      firstIdElement.setAttribute('tabIndex', '0');\n    }\n  }\n};\n/**\n * @hidden\n */\n\n\nvar onGetSnapshotBeforeUpdate = function onGetSnapshotBeforeUpdate(options) {\n  var contextStateRef = options.contextStateRef,\n      navigationStateRef = options.navigationStateRef,\n      document = options.document;\n\n  if (contextStateRef.current && navigationStateRef.current && document) {\n    var activeElement = document.activeElement;\n    var activeId = navigationTools.getNavigatableId(activeElement);\n\n    if (activeId && activeId === contextStateRef.current.activeId) {\n      navigationStateRef.current.activeElementIsFocused = true;\n    }\n  }\n};\n/**\n * @hidden\n */\n\n\nvar onComponentDidUpdate = function onComponentDidUpdate(options) {\n  var scope = options.scope,\n      contextStateRef = options.contextStateRef,\n      navigationStateRef = options.navigationStateRef;\n  generateMatrix(options); // check if nested navigation\n\n  if (contextStateRef.current && navigationStateRef.current && scope) {\n    var activeElement = navigationTools.getActiveElement(scope, contextStateRef.current.activeId);\n\n    if (!activeElement) {\n      var firstId = navigationStateRef.current.navigationMatrix[0][0];\n      var firstIdElement = navigationTools.getActiveElement(scope, firstId);\n\n      if (firstId && firstIdElement) {\n        contextStateRef.current.activeId = firstId;\n        firstIdElement.setAttribute('tabIndex', '0');\n\n        if (navigationStateRef.current.activeElementIsFocused) {\n          firstIdElement.focus();\n        }\n      }\n    }\n\n    navigationStateRef.current.activeElementIsFocused = false;\n  }\n};\n/**\n * @hidden\n */\n\n\nvar onFocus = function onFocus(event, options) {\n  var contextStateRef = options.contextStateRef;\n\n  if (event.isDefaultPrevented()) {\n    return;\n  }\n\n  if (!contextStateRef.current) {\n    return;\n  }\n\n  var focusedElement = event.target;\n  var activeId = navigationTools.getNavigatableId(focusedElement);\n\n  if (activeId && activeId !== contextStateRef.current.activeId) {\n    var scope = navigationTools.getClosestScope(focusedElement);\n\n    if (!scope) {\n      return;\n    }\n\n    var prevElement = navigationTools.getActiveElement(scope, contextStateRef.current.activeId);\n\n    if (prevElement) {\n      prevElement.setAttribute('tabIndex', '-1');\n    }\n\n    focusedElement.setAttribute('tabIndex', '0');\n    contextStateRef.current.activeId = activeId;\n  }\n};\n/**\n * @hidden\n */\n\n\nvar onKeyDown = function onKeyDown(event, options) {\n  var contextStateRef = options.contextStateRef,\n      navigationStateRef = options.navigationStateRef;\n\n  if (event.isDefaultPrevented()) {\n    return;\n  }\n\n  if (!contextStateRef.current || !navigationStateRef.current) {\n    return;\n  }\n\n  if (event.keyCode === Keys.esc) {\n    // activate navigation\n    var elementForFocus = navigationTools.getClosestNavigatableElement(event.target);\n    navigationTools.focusElement({\n      elementForFocus: elementForFocus,\n      event: event,\n      contextStateRef: contextStateRef\n    });\n    return;\n  }\n\n  var element = event.target;\n  var elementId = navigationTools.getNavigatableId(element);\n  var dataLevel = navigationTools.getNavigatableLevel(element);\n  var scope = navigationTools.getClosestScope(element);\n  var matrix = navigationStateRef.current.navigationMatrix;\n\n  if (dataLevel !== undefined && scope) {\n    if (event.keyCode === Keys.enter) {\n      // activate nested navigation or focus focusable element\n      var navigatableElement = navigationTools.getNavigatableElement(element, {\n        level: dataLevel + 1\n      });\n\n      if (navigatableElement) {\n        navigationTools.focusElement({\n          elementForFocus: navigatableElement,\n          event: event,\n          contextStateRef: contextStateRef,\n          prevElement: element\n        });\n        return;\n      } else {\n        var elementForFocus = navigationTools.getFocusableElements(element)[0];\n        navigationTools.focusElement({\n          elementForFocus: elementForFocus,\n          event: event,\n          contextStateRef: contextStateRef,\n          prevElement: element\n        });\n        return;\n      }\n    }\n\n    if (event.keyCode === Keys.up || event.keyCode === Keys.down || event.keyCode === Keys.left || event.keyCode === Keys.right) {\n      var isReverse = event.keyCode === Keys.up || event.keyCode === Keys.left;\n      var isVertical = event.keyCode === Keys.up || event.keyCode === Keys.down;\n      var currentIdIndexes = void 0;\n\n      if (navigationStateRef.current && navigationStateRef.current.prevNavigationIndexes) {\n        var _a = navigationStateRef.current.prevNavigationIndexes,\n            rowIndex = _a[0],\n            cellIndex = _a[1];\n\n        if (matrix[rowIndex][cellIndex] === elementId) {\n          currentIdIndexes = navigationStateRef.current.prevNavigationIndexes;\n        } else {\n          currentIdIndexes = findId(matrix, elementId);\n        }\n      } else {\n        currentIdIndexes = findId(matrix, elementId);\n      }\n\n      if (currentIdIndexes) {\n        var rowIndex = currentIdIndexes[0],\n            cellIndex = currentIdIndexes[1];\n\n        var _b = isVertical ? findNextIdByRowIndex(rowIndex, cellIndex, elementId, matrix, isReverse) : findNextIdByCellIndex(rowIndex, cellIndex, elementId, matrix, isReverse),\n            idForFocus = _b[0],\n            currentIndexes = _b[1];\n\n        if (idForFocus) {\n          var elementForFocus = navigationTools.getActiveElement(scope, idForFocus);\n          navigationTools.focusElement({\n            elementForFocus: elementForFocus,\n            event: event,\n            contextStateRef: contextStateRef,\n            prevElement: element\n          });\n          navigationStateRef.current.prevNavigationIndexes = currentIndexes;\n        }\n      }\n    }\n  }\n};\n/**\n * @hidden\n */\n\n\nvar generateHeaderMatrix = function generateHeaderMatrix(options) {\n  var columns = options.columns,\n      filterColumns = options.filterColumns,\n      navigationStateRef = options.navigationStateRef;\n\n  if (!navigationStateRef.current) {\n    return;\n  }\n\n  var matrix = [];\n  var maxDepth = 0;\n  columns.forEach(function (column) {\n    return maxDepth = Math.max(maxDepth, column.depth);\n  });\n  columns.forEach(function (column) {\n    if (!matrix[column.depth]) {\n      matrix[column.depth] = [];\n    }\n\n    matrix[column.depth][matrix[column.depth].length] = column.id;\n\n    if (column.colSpan > 1) {\n      for (var colSpan = 2; colSpan <= column.colSpan; colSpan++) {\n        var colIndex = matrix[column.depth].length;\n        matrix[column.depth][colIndex] = column.id;\n      }\n    }\n\n    if (!column.children.length) {\n      for (var depth = column.depth + 1; depth <= maxDepth; depth++) {\n        if (!matrix[depth]) {\n          matrix[depth] = [];\n        }\n\n        var colIndex = matrix[depth].length;\n        matrix[depth][colIndex] = column.id;\n      }\n    }\n  });\n\n  if (filterColumns) {\n    filterColumns.forEach(function (col) {\n      if (!matrix[maxDepth + 1]) {\n        matrix[maxDepth + 1] = [];\n      }\n\n      var colIndex = matrix[maxDepth + 1].length;\n      matrix[maxDepth + 1][colIndex] = \"\" + col.id + KEYBOARD_NAV_FILTER_COL_SUFFIX;\n    });\n  }\n\n  navigationStateRef.current.navigationMatrix = matrix;\n  navigationStateRef.current.lastHeaderIndex = matrix.length - 1;\n};\n/**\n * @hidden\n */\n\n\nvar generateRowMatrix = function generateRowMatrix(options) {\n  var cellId = options.cellId,\n      colSpan = options.colSpan,\n      navigationStateRef = options.navigationStateRef,\n      rowIndex = options.rowIndex;\n\n  if (!navigationStateRef.current) {\n    return;\n  }\n\n  var matrix = navigationStateRef.current.navigationMatrix;\n\n  if (!matrix[rowIndex]) {\n    matrix[rowIndex] = [];\n  }\n\n  for (var i = 1; i <= colSpan; i++) {\n    matrix[rowIndex].push(cellId);\n  }\n};\n/**\n * @hidden\n */\n\n\nvar generateMatrix = function generateMatrix(options) {\n  var navigationStateRef = options.navigationStateRef,\n      scope = options.scope;\n\n  if (!navigationStateRef.current || !scope) {\n    return;\n  }\n\n  var matrix = [];\n  var thead = getHeaderElement(scope);\n  var tbody = getBodyElement(scope);\n\n  if (!thead || !tbody) {\n    return;\n  }\n\n  var headerRows = Array.from(thead.children);\n  var bodyRows = Array.from(tbody.children);\n  headerRows.concat(bodyRows).forEach(function (row, rowIndex) {\n    Array.from(row.children).forEach(function (cell) {\n      var cellId = getNavigatableId(cell);\n\n      if (!cellId) {\n        return;\n      } // cell is not navigatable\n\n\n      var rowSpan = cell.rowSpan || 1;\n      var cellSpan = cell.colSpan || 1;\n      var cellIndex;\n\n      for (var depth = rowIndex, maxDepth = rowIndex + rowSpan; depth < maxDepth; depth++) {\n        if (!matrix[depth]) {\n          matrix[depth] = [];\n        }\n\n        if (cellIndex === undefined) {\n          var freeSlotIndex = matrix[depth].findIndex(function (mi) {\n            return !mi;\n          });\n          cellIndex = freeSlotIndex > -1 ? freeSlotIndex : matrix[depth].length;\n        }\n\n        matrix[depth][cellIndex] = cellId || '';\n      }\n\n      for (var depth = cellIndex + 1, maxDepth = cellIndex + cellSpan; depth < maxDepth; depth++) {\n        matrix[rowIndex][depth] = cellId || '';\n      }\n    });\n  });\n  navigationStateRef.current.navigationMatrix = matrix.filter(function (row) {\n    return !!row;\n  });\n  navigationStateRef.current.lastHeaderIndex = headerRows.length - 1;\n};\n/**\n * @hidden\n */\n\n\nexport var tableKeyboardNavigation = {\n  onConstructor: onConstructor,\n  onComponentDidMount: onComponentDidMount,\n  onGetSnapshotBeforeUpdate: onGetSnapshotBeforeUpdate,\n  onComponentDidUpdate: onComponentDidUpdate,\n  onFocus: onFocus,\n  onKeyDown: onKeyDown,\n  generateHeaderMatrix: generateHeaderMatrix,\n  generateRowMatrix: generateRowMatrix,\n  generateMatrix: generateMatrix\n};","map":null,"metadata":{},"sourceType":"module"}