{"ast":null,"code":"import { addItem, removeItem } from './utils/itemUtils';\nimport { getDecrementedItemIdAfterRemoval, getItemById } from './utils/itemIdUtils';\n/**\n *  A helper function which moves a TreeView item in an immutable way.\n * @param sourceItemHierarchicalIndex - The hierarchical index of the item that will be moved.\n * @param sourceData - The tree which contains the item that will be moved.\n * @param operation - The specific move operation.\n *\n * The available options are:\n *  * `before`&mdash;Indicates that the source item will become the previous sibling of the target item.\n *  * `after`&mdash;Indicates that the source item will become the next sibling of the target item.\n *  * `child`&mdash;Indicates that the source item will become a child of the target item.\n * @param targetItemHierarchicalIndex - The hierarchical index of the item next to which the source item will be moved.\n * @param targetData - The tree which contains the target item.\n * If the argument is skipped, then the move operation will be executed within the same tree.\n * Setting the `sourceData` and `targetData` arguments to the same tree is also supported.\n * @returns - The updated copies of the `sourceData` and `targetData` input arguments.\n * If `targetData` is not passed, then only the updated copy of the `sourceData` will be returned.\n *\n * @example\n * ```jsx\n * class App extends React.Component {\n *     dragClue;\n *     state = { tree };\n *\n *     render() {\n *         return (\n *             <div>\n *                 <TreeView data={this.state.tree} draggable={true}\n *                     onItemDragOver={this.onItemDragOver} onItemDragEnd={this.onItemDragEnd} />\n *                 <TreeViewDragClue ref={dragClue => this.dragClue = dragClue} />\n *             </div>\n *         );\n *     }\n *\n *     onItemDragOver = (event) => {\n *         this.dragClue.show(event.pageY + 10, event.pageX, event.item.text, this.getClueClassName(event));\n *     }\n *     onItemDragEnd = (event) => {\n *         this.dragClue.hide();\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             const updatedTree = moveTreeViewItem(\n *                 event.itemHierarchicalIndex,\n *                 this.state.tree,\n *                 eventAnalyzer.getDropOperation(),\n *                 eventAnalyzer.destinationMeta.itemHierarchicalIndex,\n *             );\n *\n *             this.setState({ tree: updatedTree });\n *         }\n *     }\n *     getClueClassName(event) {\n *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();\n *         const itemIndex = eventAnalyzer.destinationMeta.itemHierarchicalIndex;\n *\n *         if (eventAnalyzer.isDropAllowed) {\n *             switch (eventAnalyzer.getDropOperation()) {\n *                 case 'child':\n *                     return 'k-i-plus';\n *                 case 'before':\n *                     return itemIndex === '0' || itemIndex.endsWith(`${SEPARATOR}0`) ?\n *                         'k-i-insert-up' : 'k-i-insert-middle';\n *                 case 'after':\n *                     const siblings = getSiblings(itemIndex, this.state.tree);\n *                     const lastIndex = Number(itemIndex.split(SEPARATOR).pop());\n *\n *                     return lastIndex < siblings.length - 1 ? 'k-i-insert-middle' : 'k-i-insert-down';\n *                 default:\n *                     break;\n *             }\n *         }\n *\n *         return 'k-i-cancel';\n *     }\n * }\n *\n * function getSiblings(itemIndex, data) {\n *     let result = data;\n *\n *     const indices = itemIndex.split(SEPARATOR).map(index => Number(index));\n *     for (let i = 0; i < indices.length - 1; i++) {\n *         result = result[indices[i]].items;\n *     }\n *\n *     return result;\n * }\n *\n * const SEPARATOR = '_';\n * const tree = [{\n *     text: 'Furniture', expanded: true, items: [\n *         { text: 'Tables & Chairs', expanded: true },\n *         { text: 'Sofas', expanded: true },\n *         { text: 'Occasional Furniture', expanded: true }]\n * }, {\n *     text: 'Decor', expanded: true, items: [\n *         { text: 'Bed Linen', expanded: true },\n *         { text: 'Curtains & Blinds', expanded: true },\n *         { text: 'Carpets', expanded: true }]\n * }];\n *\n * ReactDOM.render(<App />, document.querySelector('my-app'));\n * ```\n */\n\nexport default function moveTreeViewItem(sourceItemHierarchicalIndex, sourceData, operation, targetItemHierarchicalIndex, targetData) {\n  if (!validateInput()) {\n    return prepareInputDataForReturn();\n  }\n\n  var sourceItem = getItemById(sourceItemHierarchicalIndex, sourceData);\n\n  if (!sourceItem) {\n    return prepareInputDataForReturn();\n  } // The source and the target tree are the same.\n\n\n  if (!targetData || targetData === sourceData) {\n    if (!validateNoCircularReference()) {\n      return prepareInputDataForReturn();\n    }\n\n    var updatedSourceData = removeItem(sourceItemHierarchicalIndex, sourceData);\n    var resultData = addItem(sourceItem, operation, getDecrementedItemIdAfterRemoval(sourceItemHierarchicalIndex, targetItemHierarchicalIndex), updatedSourceData); // A simpler output is explicitly returned when the source and the target tree are\n    // the same, that is, the targetData argument is skipped.\n\n    return targetData ? {\n      sourceData: resultData,\n      targetData: resultData\n    } : resultData;\n  } else {\n    var updatedSource = removeItem(sourceItemHierarchicalIndex, sourceData);\n    var updatedTarget = addItem(sourceItem, operation, targetItemHierarchicalIndex, targetData);\n    return {\n      sourceData: updatedSource,\n      targetData: updatedTarget\n    };\n  }\n\n  function prepareInputDataForReturn() {\n    return targetData ? {\n      sourceData: sourceData,\n      targetData: targetData\n    } : sourceData;\n  }\n\n  function validateNoCircularReference() {\n    return !(targetItemHierarchicalIndex + \"_\").startsWith(sourceItemHierarchicalIndex + \"_\");\n  }\n\n  function validateInput() {\n    if (!sourceData || !sourceData.length || !sourceItemHierarchicalIndex || !targetItemHierarchicalIndex) {\n      return false;\n    }\n\n    if (targetData && !targetData.length) {\n      // Dropping over an empty tree is not supported.\n      return false;\n    } // Validate that the target item exists.\n\n\n    var data = !targetData || targetData === sourceData ? sourceData : targetData;\n\n    if (!getItemById(targetItemHierarchicalIndex, data)) {\n      return false;\n    }\n\n    return true;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}