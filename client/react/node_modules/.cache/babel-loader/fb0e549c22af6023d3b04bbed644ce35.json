{"ast":null,"code":"import { generateNavigatableId } from '../../navigation/utils';\nimport { ColumnDefaultProps } from '../ColumnProps';\n\nfunction nextColumn(columns, current) {\n  var currentDepth = columns[current].depth;\n  var next = null;\n\n  for (var index = current + 1; index < columns.length; index++) {\n    if (columns[index].depth === currentDepth) {\n      next = columns[index];\n      break;\n    }\n  }\n\n  return next;\n}\n/**\n * @hidden\n */\n\n\nexport function mapColumns(columns) {\n  var columnsMap = [[]];\n  var maxDepth = 0; // set colspans, get maxdepth\n\n  for (var q = columns.length - 1; q >= 0; q--) {\n    maxDepth = Math.max(maxDepth, columns[q].depth);\n    columns[q].colSpan = columns[q].colSpan || 1;\n\n    if (columns[q].parentIndex !== -1) {\n      columns[columns[q].parentIndex].colSpan = (columns[columns[q].parentIndex].colSpan || 0) + columns[q].colSpan;\n    }\n  }\n\n  var rowSpan = 1; // set rowspan, kFirst, index AND create columnsMap\n\n  columns.forEach(function (column, i) {\n    columnsMap[column.depth] = columnsMap[column.depth] || [];\n    var needKFirst = false;\n\n    if (columnsMap[column.depth].length === 0) {\n      if (rowSpan <= 1) {\n        rowSpan = 1 + (column.children.length > 0 ? 0 : maxDepth - column.depth);\n      } else {\n        rowSpan--;\n        needKFirst = true;\n      }\n    }\n\n    column.rowSpan = 1 + (column.children.length > 0 ? 0 : maxDepth - column.depth);\n    column.kFirst = needKFirst;\n    column.index = columnsMap[column.depth].length;\n    columnsMap[column.depth].push(i);\n  });\n  var stickyLeftWidth = new Array(columnsMap.length).fill(0);\n  var width = 0; // set left AND create stickyLeftWidth\n\n  columns.forEach(function (column) {\n    if (column.locked) {\n      column.left = stickyLeftWidth[column.depth];\n      width = column.width ? parseFloat(column.width.toString()) : 0;\n\n      if (column.children.length === 0) {\n        for (var i = column.depth; i < stickyLeftWidth.length; i++) {\n          stickyLeftWidth[i] += width;\n        }\n      } else {\n        stickyLeftWidth[column.depth] += width;\n      }\n    }\n  });\n  var stickyRightWidth = new Array(columnsMap.length).fill(0); // set right, rightBorder AND create stickyRightWidth\n\n  for (var i = columns.length - 1; i >= 0; i--) {\n    var column = columns[i];\n\n    if (column.locked) {\n      column.right = stickyRightWidth[column.depth];\n      width = column.width ? parseFloat(column.width.toString()) : 0;\n\n      if (column.children.length === 0) {\n        for (var j = column.depth; j < stickyRightWidth.length; j++) {\n          stickyRightWidth[j] += width;\n        }\n      } else {\n        stickyRightWidth[column.depth] += width;\n      }\n\n      var next = nextColumn(columns, i);\n      column.rightBorder = !(next && next.locked);\n    }\n  }\n\n  return columnsMap;\n}\n/**\n * @hidden\n */\n\nexport function readColumns(elements, idInfo, depth) {\n  if (depth === void 0) {\n    depth = 0;\n  }\n\n  var columns = [];\n\n  if (!elements || !elements.length) {\n    return [];\n  }\n\n  elements.forEach(function (columnProps) {\n    var children = readColumns(columnProps.children || [], idInfo, depth + 1);\n    columns.push(Object.assign({}, {\n      depth: depth\n    }, ColumnDefaultProps, columnProps, {\n      id: generateNavigatableId(\"\" + idInfo.prevId++, idInfo.idPrefix, 'column'),\n      declarationIndex: columns.length,\n      children: children,\n      rowSpan: 0,\n      colSpan: 0\n    }));\n  });\n\n  var comparator = function comparator(a, b) {\n    return a.orderIndex === b.orderIndex ? a.declarationIndex - b.declarationIndex : (a.orderIndex || 0) - (b.orderIndex || 0);\n  };\n\n  columns.sort(comparator);\n\n  if (depth === 0) {\n    var ret_1 = [];\n\n    var flat_1 = function flat_1(cols, pIndex) {\n      return cols.forEach(function (c) {\n        c.parentIndex = pIndex;\n        flat_1(c.children, ret_1.push(c) - 1);\n      });\n    };\n\n    flat_1(columns, -1);\n    return ret_1;\n  }\n\n  return columns;\n}\n/**\n * @hidden\n */\n\nexport function isRtl(element) {\n  return Boolean(element && getComputedStyle(element).direction === 'rtl');\n}\n/**\n * @hidden\n */\n\nexport function getIndex(event, parent) {\n  if (!parent || !event || !event.originalEvent) {\n    return -1;\n  }\n\n  var target = document ? document.elementFromPoint(event.clientX, event.originalEvent.clientY) : null;\n\n  while (target && target.parentElement !== parent) {\n    target = target.parentElement;\n  }\n\n  var children = parent.children;\n\n  for (var i = 0; i < children.length; i++) {\n    if (children[i] === target) {\n      return i;\n    }\n  }\n\n  return -1;\n}","map":null,"metadata":{},"sourceType":"module"}