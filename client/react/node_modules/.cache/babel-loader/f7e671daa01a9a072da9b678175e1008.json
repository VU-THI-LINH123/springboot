{"ast":null,"code":"import { timezones } from './timezones';\nimport { ruleToDate } from './rule-to-date';\nvar CURRENT_UTC_TIME = new Date().getTime();\n/**\n * @hidden\n *\n * A function that finds zone rules which become applicable after a specific time.\n *\n * @param timezone - The timezone name. For example, `America/Chicago`, `Europe/Sofia`.\n * @param utcTime - The UTC time boundary for a zone rule. Defaults to the current UTC time.\n *\n * @return - Returns a zone rule for the specific zone name.\n *\n * @example\n * ```ts-no-run\n * findZone('Europe/Sofia'); //[-120,\"EU\",\"EE%sT\",null]\n * ```\n */\n\nexport var findRule = function findRule(zoneRule, utcTime, zoneOffset) {\n  if (utcTime === void 0) {\n    utcTime = CURRENT_UTC_TIME;\n  }\n\n  if (zoneOffset === void 0) {\n    zoneOffset = 0;\n  }\n\n  var rules = timezones.rules[zoneRule];\n\n  if (!rules) {\n    var time = zoneRule.split(\":\");\n    var offset = 0;\n\n    if (time.length > 1) {\n      offset = time[0] * 60 + Number(time[1]);\n    }\n\n    return [-1000000, 'max', '-', 'Jan', 1, [0, 0, 0], offset, '-'];\n  }\n\n  var year = new Date(utcTime).getUTCFullYear();\n  rules = rules.filter(function (currentRule) {\n    var from = currentRule[0];\n    var to = currentRule[1];\n    return from <= year && (to >= year || from === year && to === \"only\" || to === \"max\");\n  });\n  rules.push(utcTime);\n  rules.sort(function (a, b) {\n    if (typeof a !== \"number\") {\n      a = Number(ruleToDate(year, a, zoneOffset));\n    }\n\n    if (typeof b !== \"number\") {\n      b = Number(ruleToDate(year, b, zoneOffset));\n    }\n\n    return a - b;\n  });\n  var rule = rules[rules.indexOf(utcTime) - 1] || rules[rules.length - 1];\n  return isNaN(rule) ? rule : null;\n};","map":null,"metadata":{},"sourceType":"module"}